@startuml PlayerStateClass





/' Objects '/

class PlayerState {
	+PlayerState(size_t playerID, size_t score)
	+PlayerState(const PlayerState &)
	+PlayerState(PlayerState& &)
	+~PlayerState()
	+getPlayerID() : PlayerID {query}
	+operator=(const PlayerState &) : PlayerState&
	+operator=(PlayerState& &) : PlayerState&
	+getScore() : Score {query}
	-pActiveBonus_ : TimedBonusPtr
	+getActiveBonus() : TimedBonusPtr&
	-pActivePenalty_ : TimedPenaltyPtr
	+getActivePenalty() : TimedPenaltyPtr&
	+isAlive() : bool {query}
	-isAlive_ : bool
	+isGameTick() : bool
	+serializeExternal() : nlohmann::json {query}
	+serializeSelf() : nlohmann::json {query}
	-playerID_ : size_t
	-score_ : size_t
	+getStashedPenalties() : std::deque<PenaltyType>
	+fetchGrantedBonus() : std::optional<BonusType>
	-energy_ : std::optional<Energy>
	+getEnergy() : std::optional<Energy> {query}
	+fetchReceivedPenalty() : std::optional<PenaltyType>
	+getPenaltyTarget() : std::optional<PlayerID> {query}
	-penaltyTarget_ : std::optional<PlayerID>
	-engineTicksSinceLastTick_ : std::optional<size_t>
	-stashedPenalties_ : std::optional<std::deque<PenaltyType>>
	-grantedBonusesQueue_ : std::optional<std::queue<BonusType>>
	-receivedPenaltiesQueue_ : std::optional<std::queue<PenaltyType>>
	-effectsPrice : std::vector<EffectPrice>
	+decreaseEnergy(size_t amount) : void
	+grantBonus(BonusType bonus) : void
	+increaseEnergy(size_t amount) : void
	+increaseScore(size_t val) : void
	+notifyActiveTetrominoPlaced() : void
	+notifyEngineTick() : void
	+notifyLost() : void
	+receivePenalty(PenaltyType penalty) : void
	+setActiveBonus(const TimedBonusPtr& pTimedBonus) : void
	+setActivePenalty(const TimedPenaltyPtr& pTimedPenalty) : void
	+setAlive(bool isAlive) : void
	+setPenaltyTarget(size_t playerID) : void
	+stashPenalty(PenaltyType penalty) : void
	+toggleEffects(bool activated) : void
}





/' Inheritance relationships '/




/' Aggregation relationships '/





/' Nested objects '/



@enduml
